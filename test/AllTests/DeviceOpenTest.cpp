#include "CppUTest/TestHarness.h"
#include "CppUTestExt/MockSupport.h"
#include "IOMemDevMock.h"
#include "CharDevMock.h"

extern "C" {
    #include "linux/module.h"
    #include "linux/fs.h"
    #include "main.h"
    ModuleInitFuncPtr __inittest(void);
}

TEST_GROUP(DeviceOpenTest)
{
    void setup() {
    }

    void teardown() {
    }

    int initialize_module() {
        return __inittest()();
    }
};

TEST(DeviceOpenTest, fops_has_open)
{
    CHECK(tddmodule_fops.open);
}

TEST(DeviceOpenTest, open_succeeds)
{
    struct file fil;
    struct inode inode;

    mock(iomem_mock_namespace).expectOneCall("readl")
        .withParameter("addr", (void*) &tddmodule_registers_p->status)
        .andReturnValue(1);
    mock().ignoreOtherCalls();
    CHECK(!tddmodule_dev_open( &inode, &fil));
}


TEST(DeviceOpenTest, open_initializes_filp_private_data)
{
    struct file fil;
    struct inode inode;

    mock(iomem_mock_namespace).expectOneCall("readl")
        .withParameter("addr", (void*) &tddmodule_registers_p->status)
        .andReturnValue(1);
    mock().ignoreOtherCalls();
    tddmodule_dev_open( &inode, &fil);
    CHECK_EQUAL(&tddmodule_dev, fil.private_data);
}


TEST(DeviceOpenTest, open_initializes_hardware)
{
    struct file fil;
    struct inode inode;
    int read_wait_loop;
    u32 expected_control_write_addr = tddmodule_registers_p->control;
    u32 expected_control_read_addr = tddmodule_registers_p->status;
    u32 expected_control_reset_value = TDDMODULE_DEV_CONTROL_RESET;

    EXPECT_N_LEAKS(1);

    mock(fs_mock_namespace).ignoreOtherCalls();
    initialize_module();

    mock(iomem_mock_namespace).expectOneCall("writel")
        .withParameterOfType("unsigned", "value",
            &expected_control_reset_value)
        .withParameter("addr", (void*) &tddmodule_registers_p->control);
    mock(iomem_mock_namespace).expectOneCall("mb");
    // force device to not be ready for N reads
    mock(iomem_mock_namespace).expectNCalls(5, "readl")
        .withParameter("addr", (void*) &tddmodule_registers_p->status)
        .andReturnValue(0);
    mock(iomem_mock_namespace).expectOneCall("readl")
        .withParameter("addr", (void*) &tddmodule_registers_p->status)
        .andReturnValue(1);
    tddmodule_dev_open( &inode, &fil);
}

